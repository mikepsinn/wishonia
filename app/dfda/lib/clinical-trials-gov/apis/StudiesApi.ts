;
/* tslint:disable */
/* eslint-disable */
/**
 * ClinicalTrials.gov REST API
 * This API is made available to provide users meta data, statistics, and the most recent version of the clinical trials available on ClinicalTrials.gov.
 *
 * The version of the OpenAPI document: 2.0.3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { EnumInfo, FieldNode, PagedStudies, SearchDocument, Status } from "../models/index";
import { EnumInfoFromJSON, FieldNodeFromJSON, PagedStudiesFromJSON, SearchDocumentFromJSON } from "../models/index";
import * as runtime from "../runtime";


export interface FetchStudyRequest {
  nctId: string
  format?: FetchStudyFormatEnum
  markupFormat?: FetchStudyMarkupFormatEnum
  fields?: Array<string>
}

export interface ListStudiesRequest {
  format?: ListStudiesFormatEnum
  markupFormat?: ListStudiesMarkupFormatEnum
  queryCond?: string
  queryTerm?: string
  queryLocn?: string
  queryTitles?: string
  queryIntr?: string
  queryOutc?: string
  querySpons?: string
  queryLead?: string
  queryId?: string
  queryPatient?: string
  filterOverallStatus?: Array<Status>
  filterGeo?: string
  filterIds?: Array<string>
  filterAdvanced?: string
  filterSynonyms?: Array<string>
  postFilterOverallStatus?: Array<Status>
  postFilterGeo?: string
  postFilterIds?: Array<string>
  postFilterAdvanced?: string
  postFilterSynonyms?: Array<string>
  aggFilters?: string
  geoDecay?: string
  fields?: Array<string>
  sort?: Array<string>
  countTotal?: boolean
  pageSize?: number
  pageToken?: string
}

export interface StudiesMetadataRequest {
  includeIndexedOnly?: boolean
  includeHistoricOnly?: boolean
}

/**
 *
 */
export class StudiesApi extends runtime.BaseAPI {
  /**
   * Returns enumeration types and their values.  Every item of the returning array represents enum type and contains the following properties: * `type` - enum type name * `pieces` - array of names of all data pieces having the enum type * `values` - all available values of the enum; every item contains the following properties:   * `value` - data value   * `legacyValue` - data value in legacy API   * `exceptions` - map from data piece name to legacy value when different from `legacyValue`     (some data pieces had special enum values in legacy API)
   * Enums
   */
  async enumsRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<EnumInfo>>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/studies/enums`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(EnumInfoFromJSON)
    )
  }

  /**
   * Returns enumeration types and their values.  Every item of the returning array represents enum type and contains the following properties: * `type` - enum type name * `pieces` - array of names of all data pieces having the enum type * `values` - all available values of the enum; every item contains the following properties:   * `value` - data value   * `legacyValue` - data value in legacy API   * `exceptions` - map from data piece name to legacy value when different from `legacyValue`     (some data pieces had special enum values in legacy API)
   * Enums
   */
  async enums(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<EnumInfo>> {
    const response = await this.enumsRaw(initOverrides)
    return await response.value()
  }

  /**
   * Returns data of a single study.
   * Single Study
   */
  async fetchStudyRaw(
    requestParameters: FetchStudyRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters["nctId"] == null) {
      throw new runtime.RequiredError(
        "nctId",
        'Required parameter "nctId" was null or undefined when calling fetchStudy().'
      )
    }

    const queryParameters: any = {}

    if (requestParameters["format"] != null) {
      queryParameters["format"] = requestParameters["format"]
    }

    if (requestParameters["markupFormat"] != null) {
      queryParameters["markupFormat"] = requestParameters["markupFormat"]
    }

    if (requestParameters["fields"] != null) {
      queryParameters["fields"] = requestParameters["fields"]!.join(
        runtime.COLLECTION_FORMATS["pipes"]
      )
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/studies/{nctId}`.replace(
          `{${"nctId"}}`,
          encodeURIComponent(String(requestParameters["nctId"]))
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<string>(response)
    } else {
      return new runtime.TextApiResponse(response) as any
    }
  }

  /**
   * Returns data of a single study.
   * Single Study
   */
  async fetchStudy(
    requestParameters: FetchStudyRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<string> {
    const response = await this.fetchStudyRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Returns data of studies matching query and filter parameters. The studies are returned page by page. If response contains `nextPageToken`, use its value in `pageToken` to get next page. The last page will not contain `nextPageToken`. A page may have empty `studies` array. Request for each subsequent page **must** have the same parameters as for the first page, except `countTotal`, `pageSize`, and `pageToken` parameters.  If neither queries nor filters are set, all studies will be returned. If any query parameter contains only NCT IDs (comma- and/or space-separated), filters are ignored.  `query.*` parameters are in [Essie expression syntax](/find-studies/constructing-complex-search-queries). Those parameters affect ranking of studies, if sorted by relevance. See `sort` parameter for details.  `filter.*` and `postFilter.*` parameters have same effect as there is no aggregation calculation.  Both are available just to simplify applying parameters from search request. Both do not affect ranking of studies.  Note: When trying JSON format in your browser, do not set too large `pageSize` parameter, if `fields` is unlimited. That may return too much data for the browser to parse and render.
   * Studies
   */
  async listStudiesRaw(
    requestParameters: ListStudiesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<PagedStudies>> {
    const queryParameters: any = {}

    if (requestParameters["format"] != null) {
      queryParameters["format"] = requestParameters["format"]
    }

    if (requestParameters["markupFormat"] != null) {
      queryParameters["markupFormat"] = requestParameters["markupFormat"]
    }

    if (requestParameters["queryCond"] != null) {
      queryParameters["query.cond"] = requestParameters["queryCond"]
    }

    if (requestParameters["queryTerm"] != null) {
      queryParameters["query.term"] = requestParameters["queryTerm"]
    }

    if (requestParameters["queryLocn"] != null) {
      queryParameters["query.locn"] = requestParameters["queryLocn"]
    }

    if (requestParameters["queryTitles"] != null) {
      queryParameters["query.titles"] = requestParameters["queryTitles"]
    }

    if (requestParameters["queryIntr"] != null) {
      queryParameters["query.intr"] = requestParameters["queryIntr"]
    }

    if (requestParameters["queryOutc"] != null) {
      queryParameters["query.outc"] = requestParameters["queryOutc"]
    }

    if (requestParameters["querySpons"] != null) {
      queryParameters["query.spons"] = requestParameters["querySpons"]
    }

    if (requestParameters["queryLead"] != null) {
      queryParameters["query.lead"] = requestParameters["queryLead"]
    }

    if (requestParameters["queryId"] != null) {
      queryParameters["query.id"] = requestParameters["queryId"]
    }

    if (requestParameters["queryPatient"] != null) {
      queryParameters["query.patient"] = requestParameters["queryPatient"]
    }

    if (requestParameters["filterOverallStatus"] != null) {
      queryParameters["filter.overallStatus"] = requestParameters[
        "filterOverallStatus"
      ]!.join(runtime.COLLECTION_FORMATS["pipes"])
    }

    if (requestParameters["filterGeo"] != null) {
      queryParameters["filter.geo"] = requestParameters["filterGeo"]
    }

    if (requestParameters["filterIds"] != null) {
      queryParameters["filter.ids"] = requestParameters["filterIds"]!.join(
        runtime.COLLECTION_FORMATS["pipes"]
      )
    }

    if (requestParameters["filterAdvanced"] != null) {
      queryParameters["filter.advanced"] = requestParameters["filterAdvanced"]
    }

    if (requestParameters["filterSynonyms"] != null) {
      queryParameters["filter.synonyms"] = requestParameters[
        "filterSynonyms"
      ]!.join(runtime.COLLECTION_FORMATS["pipes"])
    }

    if (requestParameters["postFilterOverallStatus"] != null) {
      queryParameters["postFilter.overallStatus"] = requestParameters[
        "postFilterOverallStatus"
      ]!.join(runtime.COLLECTION_FORMATS["pipes"])
    }

    if (requestParameters["postFilterGeo"] != null) {
      queryParameters["postFilter.geo"] = requestParameters["postFilterGeo"]
    }

    if (requestParameters["postFilterIds"] != null) {
      queryParameters["postFilter.ids"] = requestParameters[
        "postFilterIds"
      ]!.join(runtime.COLLECTION_FORMATS["pipes"])
    }

    if (requestParameters["postFilterAdvanced"] != null) {
      queryParameters["postFilter.advanced"] =
        requestParameters["postFilterAdvanced"]
    }

    if (requestParameters["postFilterSynonyms"] != null) {
      queryParameters["postFilter.synonyms"] = requestParameters[
        "postFilterSynonyms"
      ]!.join(runtime.COLLECTION_FORMATS["pipes"])
    }

    if (requestParameters["aggFilters"] != null) {
      queryParameters["aggFilters"] = requestParameters["aggFilters"]
    }

    if (requestParameters["geoDecay"] != null) {
      queryParameters["geoDecay"] = requestParameters["geoDecay"]
    }

    if (requestParameters["fields"] != null) {
      queryParameters["fields"] = requestParameters["fields"]!.join(
        runtime.COLLECTION_FORMATS["pipes"]
      )
    }

    if (requestParameters["sort"] != null) {
      queryParameters["sort"] = requestParameters["sort"]!.join(
        runtime.COLLECTION_FORMATS["pipes"]
      )
    }

    if (requestParameters["countTotal"] != null) {
      queryParameters["countTotal"] = requestParameters["countTotal"]
    }

    if (requestParameters["pageSize"] != null) {
      queryParameters["pageSize"] = requestParameters["pageSize"]
    }

    if (requestParameters["pageToken"] != null) {
      queryParameters["pageToken"] = requestParameters["pageToken"]
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/studies`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PagedStudiesFromJSON(jsonValue)
    )
  }

  /**
   * Returns data of studies matching query and filter parameters. The studies are returned page by page. If response contains `nextPageToken`, use its value in `pageToken` to get next page. The last page will not contain `nextPageToken`. A page may have empty `studies` array. Request for each subsequent page **must** have the same parameters as for the first page, except `countTotal`, `pageSize`, and `pageToken` parameters.  If neither queries nor filters are set, all studies will be returned. If any query parameter contains only NCT IDs (comma- and/or space-separated), filters are ignored.  `query.*` parameters are in [Essie expression syntax](/find-studies/constructing-complex-search-queries). Those parameters affect ranking of studies, if sorted by relevance. See `sort` parameter for details.  `filter.*` and `postFilter.*` parameters have same effect as there is no aggregation calculation.  Both are available just to simplify applying parameters from search request. Both do not affect ranking of studies.  Note: When trying JSON format in your browser, do not set too large `pageSize` parameter, if `fields` is unlimited. That may return too much data for the browser to parse and render.
   * Studies
   */
  async listStudies(
    requestParameters: ListStudiesRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<PagedStudies> {
    const response = await this.listStudiesRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Search Docs and their Search Areas.
   * Search Areas
   */
  async searchAreasRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<SearchDocument>>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/studies/search-areas`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(SearchDocumentFromJSON)
    )
  }

  /**
   * Search Docs and their Search Areas.
   * Search Areas
   */
  async searchAreas(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<SearchDocument>> {
    const response = await this.searchAreasRaw(initOverrides)
    return await response.value()
  }

  /**
   * Returns study data model fields.
   * Data Model Fields
   */
  async studiesMetadataRaw(
    requestParameters: StudiesMetadataRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<FieldNode>>> {
    const queryParameters: any = {}

    if (requestParameters["includeIndexedOnly"] != null) {
      queryParameters["includeIndexedOnly"] =
        requestParameters["includeIndexedOnly"]
    }

    if (requestParameters["includeHistoricOnly"] != null) {
      queryParameters["includeHistoricOnly"] =
        requestParameters["includeHistoricOnly"]
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request(
      {
        path: `/studies/metadata`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(FieldNodeFromJSON)
    )
  }

  /**
   * Returns study data model fields.
   * Data Model Fields
   */
  async studiesMetadata(
    requestParameters: StudiesMetadataRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<FieldNode>> {
    const response = await this.studiesMetadataRaw(
      requestParameters,
      initOverrides
    )
    return await response.value()
  }
}

/**
 * @export
 */
export const FetchStudyFormatEnum = {
  Csv: "csv",
  Json: "json",
  JsonZip: "json.zip",
  FhirJson: "fhir.json",
  Ris: "ris",
} as const
export type FetchStudyFormatEnum =
  (typeof FetchStudyFormatEnum)[keyof typeof FetchStudyFormatEnum]
/**
 * @export
 */
export const FetchStudyMarkupFormatEnum = {
  Markdown: "markdown",
  Legacy: "legacy",
} as const
export type FetchStudyMarkupFormatEnum =
  (typeof FetchStudyMarkupFormatEnum)[keyof typeof FetchStudyMarkupFormatEnum]
/**
 * @export
 */
export const ListStudiesFormatEnum = {
  Csv: "csv",
  Json: "json",
} as const
export type ListStudiesFormatEnum =
  (typeof ListStudiesFormatEnum)[keyof typeof ListStudiesFormatEnum]
/**
 * @export
 */
export const ListStudiesMarkupFormatEnum = {
  Markdown: "markdown",
  Legacy: "legacy",
} as const
export type ListStudiesMarkupFormatEnum =
  (typeof ListStudiesMarkupFormatEnum)[keyof typeof ListStudiesMarkupFormatEnum]
